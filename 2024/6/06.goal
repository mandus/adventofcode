#!/usr/bin/env goal 

fn:"input.txt"
(2=#ARGS) and fn:ARGS@1
d:=-read fn
l:""\"|"/d
s:1+&*d
mv:("i"$2 exp !4)!(s;-1;-s;1)
(e;m;p):{~x?l}'""\"|#^"
out:{t:x-y;w:#l;(t<0) or t>w-1}
turn:15!2*

/ for part2
broll:{x and o[-2!x],2!x}
i2b:{b:broll x; b[1+!(#b)-1]} / convert integer to bin array; strip the leading 0 from broll
b2i:{"i"$+/x*(2 exp (|!#x))} / convert bin array to integer
bip:{i:!#x|#y;+/((|x)@i)*(|y)@i} / inner prod of bin arrays; need to index with index-array i and flip order to ensure same size and alignment of bits
ibip:{bip[i2b x;i2b y]} / convenience; inner prod of bin arrays for two integers.

iter:{[p;v;m]
 cp:*&p;cd:p[cp];rv:mv[p[cp]]
 (ibip[cd;v[cp]]) and :0 / been here in same direction before; exit 
 (out[cp;rv]) and :v[cp]+:cd / leaving the area
 np:rv rotate p
 (+/np*e) and :v[cp]+:cd / hit edge -> leaving the area
 ?[+/np*m;:o[turn p;v;m];:o[np;v[cp]+:cd;m]] / hit marker, turn and try again - else update visited and continue
}
seen:iter[p;(#p)#0;m]
say "part1: ",#?&seen

addmark:?&seen[*&p]:0
say "part2: ",#&({[m;am]?[iter[p;(#p)#0;m[am]:1];0;1]} m)'addmark

/
/ First direction; go the 2d route
d:""\=-read"t1.t"
\d
m:~"#"?d
\m

p:~"^"?d
\p
spi:startposidx:*&,/p
s:stride:#*p
(r;c):(startrow;startcol):((-s)!spi;s!spi)

turn:15!2*p  / 1 = up, 2 = left, 4 = down, 8 = right - wrap back to 1 = up
/ alternative:
/ dir:1
/ dir:15!2*dir  (if we track direction and position independently)
/ if we work in 1D (flatten the array and use strid), we can move by '<num> rotate p'
/ positive number rotates left and negative to the right.
/ Since rotate will wrap around we need to make sure we don't do that!

chk:+//p*m  / 0 if not hitting anything; 1 if position hits a marker - then we turn

/ experiments - recursive function that fills a 0-array with ones
fill:{?[(#&x)<#x;(\x;x[x?0]:1;:o[x]);:x]a}
\
